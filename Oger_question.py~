import mdp.utils
import pylab
import numpy as np
import cPickle
import Oger
import matplotlib.cm as cm

epochs =1

print 'Loading data...'
data = cPickle.load(open('/home/chandru/Desktop/RNN_trials/question_extracted/question.p'))

train_len = 10 #len(data['trainquestions'])
test_len = 1000 #len(data['testquestions'])

test_data = data['trainquestions']
test_labels = data['testlabels']
train_data = data['trainquestions']
train_labels = data['trainlabels'] 

w_train_data = train_data[:train_len]
w_train_labels = train_labels[:train_len]
w_test_data = test_data[:test_len]
w_test_labels = test_labels[:test_len]


reservoir = Oger.nodes.ReservoirNode(input_dim=64, output_dim=200)
readout = Oger.nodes.RidgeRegressionNode(input_dim = 200, output_dim=6)

Oger.utils.make_inspectable(Oger.nodes.ReservoirNode)

flow = mdp.Flow([reservoir, readout], verbose=1)
#flow = mdp.Flow([reservoir], verbose=1)

x=list()
xb=list()

for j in range(0,train_len):
	y=list()
	yb = list()
	for i in range(0, len(w_train_data[j])):
		z = list()
		zb=list()

		for k in range(64):
			z.append(w_train_data[j][i][k])
		
		temp=[0 for p in range(6)]
		temp[w_train_labels[j]] = 1	

		for kb in range(6):
			zb.append(temp[kb]) #can do this appending based on when the training has to eb enforced	
			
		y.append(z)
		yb.append(zb)

	x.append(y)
	xb.append(yb)

zipped = zip(x,xb)

print(np.asarray(x).shape)
print(np.asarray(xb).shape)
print(np.asarray(zipped).shape)
#print(xb)
#print(zipped)


flow.train([x[0], [(np.array(x[0]),np.array(xb[0]))]])
#flow.train([x[1], [(np.array(x[1]),np.array(xb[1]))]])

y = flow.execute(np.array(x[0]))
#    training_states = flow.inspect(reservoir)
#    training_output = flow.inspect(output_layers)


print 'end of program'
